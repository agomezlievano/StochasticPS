return(dM)
}
unitemats <- function(A, B, withrandomness=TRUE){
nA <- nrow(A)
mA <- ncol(A)
nB <- nrow(B)
mB <- ncol(B)
if(withrandomness){
belowA <- matrix(floor(0.5*(nB + mA)/(nB*mA) + runif(nB*mA)), nrow=nB, ncol=mA)
aboveB <- matrix(floor(0.5*(nA + mB)/(nA*mB) + runif(nA*mB)), nrow=nA, ncol=mB)
} else {
belowA <- matrix(0, nrow=nB, ncol=mA)
aboveB <- matrix(0, nrow=nA, ncol=mB)
}
row.names(belowA) <- row.names(B)
colnames(belowA) <- colnames(A)
row.names(aboveB) <- row.names(A)
colnames(aboveB) <- colnames(B)
return(cbind(rbind(A, belowA), rbind(aboveB, B)))
}
eigspaces <- function(M){
cs <- colSums(M)
cs[cs==0] <- 1
Uinv <- diag(1/cs)
row.names(Uinv) <- colnames(M)
colnames(Uinv) <- colnames(M)
rs <- rowSums(M)
rs[rs==0] <- 1
Dinv <- diag(1/rs)
row.names(Dinv) <- row.names(M)
colnames(Dinv) <- row.names(M)
L <- as.matrix(M)%*%Uinv
R <- Dinv%*%as.matrix(M)
C <- L%*%t(R)
P <- t(R)%*%L
resC <- eigen(C)
resP <- eigen(P)
#Gr <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(cor(Re(x), rs)))
#Gr <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(x[which.max(rs)]))
Gr <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(Re(x[1])))
Qr <- apply(resP$vectors, MARGIN=2, function(x)Re(x)*sign(Re(x[1])))
resC <- eigen(t(C))
resP <- eigen(t(P))
#Gl <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(cor(Re(x), rs)))
#Gl <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(x[which.max(rs)]))
Gl <- apply(resC$vectors, MARGIN=2, function(x)Re(x)*sign(Re(x[1])))
Ql <- apply(resP$vectors, MARGIN=2, function(x)Re(x)*sign(Re(x[1])))
row.names(Gl) <- row.names(M)
colnames(Gl) <- row.names(M)
row.names(Gr) <- row.names(M)
colnames(Gr) <- row.names(M)
row.names(Ql) <- colnames(M)
colnames(Ql) <- colnames(M)
row.names(Qr) <- colnames(M)
colnames(Qr) <- colnames(M)
#rankofmatrix <- qr(M)$rank
return(list(Gr=Gr, Gl=Gl, C=C, Qr=Qr, Ql=Ql, P=P, values=resC$values, R=R, L=L))
}
#df <- rio::import(file = "~/../Downloads/data/M1_Matrix_30x27.csv")
df <- rio::import(file = "~/../Downloads/data/M2_Matrix_30_x_36_reordered.csv")
df[1:5, 1:5]
row.names(df) <- df$Country
df <- df %>%
select(-Country) %>%
as.data.frame()
Mcpfinal <- as.matrix(df)
resfinal <- eigspaces(Mcpfinal)
# num communities
mult.fig(1)
plot(resfinal$values, rep(1, length(resfinal$values)))
nkk <- round(sum(Re(resfinal$values)))
mycolors <- c("#e41a1c",
"#377eb8",
"#4daf4a",
"#984ea3")
letcex <- 0.2
crealcxtys <- rep(0.2, nrow(Mcpfinal))
mult.fig(2, mfrow = c(1,2))
plot(resfinal$Gl[,2], resfinal$Gl[,3],
xlim = c(-0.4,0.4),
ylim = c(-0.5, 0.35),
xlab = "Economic Complexity Index",
ylab = "3rd left-eigenvector",
main = "Left Eigenspace",
type="n")
grid()
points(0,0, pch=21, bg="black")
text(resfinal$Gl[,2], resfinal$Gl[,3], labels = row.names(resfinal$C), cex=0.8, col=mycolors[4])
for(i in c(1:nrow(Mcpfinal))){
points(resfinal$Gl[i,2], resfinal$Gl[i,3], cex=(1*crealcxtys[i]/max(crealcxtys))^2)
}
plot(resfinal$Gr[,2], resfinal$Gr[,3],
xlim = c(-0.4,0.45),
ylim = c(-0.6, 0.35),
xlab = "2nd right-eigenvector",
ylab = "3rd right-eigenvector",
main = "Right Eigenspace",
type="n")
grid()
points(0,0, pch=21, bg="black")
text(resfinal$Gr[,2], resfinal$Gr[,3], labels = row.names(resfinal$C), cex=0.8, col=mycolors[4])
for(i in c(1:nrow(Mcpfinal))){
points(resfinal$Gr[i,2], resfinal$Gr[i,3], cex=(1*crealcxtys[i]/max(crealcxtys))^2)
}
complexities1 <- diag(resfinal$Gr%*%t(resfinal$Gr)) - diag(resfinal$Gl%*%t(resfinal$Gl))
complexities2 <- sqrt(diag(resfinal$Gr%*%diag(resfinal$values)%*%t(resfinal$Gr))) - sqrt(diag(resfinal$Gl%*%diag(resfinal$values)%*%t(resfinal$Gl)))
complexities3 <- sqrt(diag(resfinal$Gr%*%diag(resfinal$values)%*%t(resfinal$Gr)))
complexities4 <- sqrt(diag(resfinal$Gr[,c(1:nkk)]%*%t(resfinal$Gr[,c(1:nkk)])))
complexities4full <- sqrt(diag(resfinal$Gr%*%t(resfinal$Gr)))
complexities5 <- diag(resfinal$Gl%*%diag(1-resfinal$values)%*%t(resfinal$Gl))
complexities6 <- diag(resfinal$Gr%*%diag(resfinal$values)%*%t(resfinal$Gl))
complexities7 <- diag(resfinal$Gr%*%t(resfinal$Gl))
ctysfull <- as.matrix(sort(complexities4full, decreasing = TRUE), ncol=1)
colnames(ctysfull) <- "Andres' Collective Knowhow metric FULL"
ctys <- as.matrix(sort(complexities4, decreasing = TRUE), ncol=1)
colnames(ctys) <- "Andres' Collective Knowhow metric"
divs <- as.matrix(sort(rowSums(Mcpfinal), decreasing = TRUE), ncol=1)
colnames(divs) <- "Diversity"
eci <- as.matrix(sort(resfinal$Gl[,2], decreasing = TRUE), ncol=1)
colnames(eci) <- "eci"
cccdf <- ctysfull %>%
merge(ctys, by=0) %>%
merge(divs, by.x="Row.names", by.y=0) %>%
merge(eci, by.x="Row.names", by.y=0) %>%
mutate(Country = Row.names) %>%
select(-Row.names) %>%
as.data.frame()
mult.fig(1)
plot(cccdf[,colnames(cccdf)!="Row.names"])
# -----------------------------------------------------------
#install.packages("NbClust",dependencies = TRUE)
library(NbClust)
cccdf <- as.data.table(cccdf)
nb <- NbClust(resfinal$Gl[,c(2:nkk)], diss=NULL, distance = "euclidean",
min.nc=2, max.nc=8, method = "kmeans",
index = "all", alphaBeale = 0.1)
cccdf[, nbnumclusters := length(unique(nb$Best.partition))]
cnames <- names(nb$Best.partition)
clusters_dt <- as.data.table(nb$Best.partition)
clusters_dt[, Country:=cnames]
setkey(clusters_dt, Country)
setkey(cccdf, Country)
cccdf[clusters_dt, on='Country', nbCluster := i.V1]
# ===========================================================
# FIGURES
# -----------------------------------------------------------
namefile <- paste0("Pepon_matrix.png")
folder.figs <- "C:/Users/agomez/Dropbox/Harvard/LittleProjects/StochasticPS/figures/"
png(paste0(folder.figs,namefile),
height=6, width=10, units="in", res=200)
mult.fig(1)
imshow(mat2im(Mcpfinal[order(-rowSums(Mcpfinal)), order(-colSums(Mcpfinal))]), 1,
main = "Triangularity of the matrix",
colmap = colorRampPalette(c('gray', 'gray10'))(100))
dev.off()
# =================================================================
# PLOTTING
# mycolors <- c("#e41a1c",
#               "#377eb8",
#               "#4daf4a",
#               "#984ea3")
mycolors <- brewer.pal(n = max(cccdf$nbCluster), name = "Dark2")
mycolors <- mycolors[c(1:length(mycolors))]
names(mycolors) <- as.character(sort(unique(cccdf$nbCluster)))
letcex <- 1
alf <- 0.9
#------
namefile <- paste0("Pepon_figs.png")
png(paste0(folder.figs,namefile),
height=4, width=14, units="in", res=600)
mult.fig(3, mfrow = c(1,3))
plot(density(Re(resfinal$values), bw = 0.05), col="gray30", lwd=3,
xlab = "Eigenvalues",
ylab = "Density",
main = "No. communities = No. large eigenvalues")
rug(jitter(Re(resfinal$values)), lwd=4, col="dodgerblue")
plot(resfinal$Gl[,2], resfinal$Gl[,3],
# xlim = c(-0.4,0.4),
# ylim = c(-0.5, 0.35),
xlab = "Economic Complexity Index",
ylab = "3rd left-eigenvector",
main = "Left Eigenspace",
type="n")
grid()
legend("topleft", title = "Communities",
cex = 1.0,
legend = names(mycolors),
pch = 21,
col = mycolors,
pt.bg = mycolors)
points(0,0, pch=21, bg="black")
text(resfinal$Gl[,2], resfinal$Gl[,3],
labels = row.names(resfinal$C),
cex=1,
col=alpha("gray50", alf))
for(cl in unique(clusters_dt$V1)){
points(resfinal$Gl[clusters_dt[V1==cl]$Country,2],
resfinal$Gl[clusters_dt[V1==cl]$Country,3],
pch = 21,
bg = alpha(mycolors[cl], alf),
col = mycolors[cl],
cex=letcex)
}
plot(resfinal$Gr[,2], resfinal$Gr[,3],
# xlim = c(-0.4,0.45),
# ylim = c(-0.6, 0.35),
xlab = "2nd right-eigenvector",
ylab = "3rd right-eigenvector",
main = "Right Eigenspace",
type="n")
grid()
points(0,0, pch=21, bg="black")
text(resfinal$Gr[,2], resfinal$Gr[,3],
labels = row.names(resfinal$C),
cex=1,
col=alpha("gray50", alf))
for(cl in unique(clusters_dt$V1)){
points(resfinal$Gr[clusters_dt[V1==cl]$Country,2],
resfinal$Gr[clusters_dt[V1==cl]$Country,3],
pch = 21,
bg = alpha(mycolors[cl], alf),
col = mycolors[cl],
cex=letcex)
}
dev.off()
rio::export(cccdf[order(-`Andres' Collective Knowhow metric`)], paste0(folder.figs, "PeponData.csv"))
cccdf[order(-`Andres' Collective Knowhow metric`)]
rio::export(cccdf[order(-`Andres' Collective Knowhow metric`)], paste0(folder.figs, "PeponData.xlsx"))
rio::export(cccdf[order(-`Andres' Collective Knowhow metric`)], paste0(folder.figs, "PeponData.xls"))
cccdf
head(cccdf)
colnames(cccdf) <- c("FULL", "ACKM", "ECI", "Country", "NBNUMCLUSTERS", "NBCLUSTER")
colnames(cccdf) <- c("FULL", "ACKM", "DIVERSITY", "ECI", "Country", "NBNUMCLUSTERS", "NBCLUSTER")
head(cccdf)
rio::export(as.data.frame(cccdf[order(-`Andres' Collective Knowhow metric`)]), paste0(folder.figs, "PeponData.csv"))
rio::export(as.data.frame(cccdf[order(-ACKM)]), paste0(folder.figs, "PeponData.csv"))
plot(c(53,37,186,76))
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- ln(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh)
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 1000)
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- ln(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh)
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 1000)
sg <- 4.5
plot(pops, Yn(pops, sg), log="xy")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh)
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 1000)
sg <- 4.5
plot(pops, Yn(pops, sg), log="xy")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh)
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 4.5
plot(pops, Yn(pops, sg), log="xy")
plot(pops, Yn(pops, sg))
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 4.5
plot(pops, Yn(pops, sg))
exp(sg^2/2)
sg <- 5.5
exp(sg^2/2)
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 5.5
exp(sg^2/2)
plot(pops, Yn(pops, sg))
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 5.5
exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 5.5
exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
lines(pops, -sg^2/2 + sg*sqrt(2*log(pops)))
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 5.5
exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
lines(pops, exp(-sg^2/2 + sg*sqrt(2*log(pops))))
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 5.5
th <- exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
lines(pops, exp(-sg^2/2 + sg*sqrt(2*log(pops))), col="blue")
abline(v = th, col="green", lty = "dotted")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 4.5
th <- exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
lines(pops, exp(-sg^2/2 + sg*sqrt(2*log(pops))), col="blue")
abline(v = th, col="green", lty = "dotted")
Yn <- function(n, sigma){
thresh <- exp(sigma^2/2)
Yofn <- exp(log(n)*(n>=thresh) + (-sigma^2/2 + sigma*sqrt(2*log(n)))*(n<thresh))
return(Yofn)
}
pops <- 10^seq(1, 7, length.out = 100)
sg <- 4.0
th <- exp(sg^2/2)
plot(pops, Yn(pops, sg), log="xy")
lines(pops, pops, col="red")
lines(pops, exp(-sg^2/2 + sg*sqrt(2*log(pops))), col="blue")
abline(v = th, col="green", lty = "dotted")
rm(list = ls(all = TRUE))  # resets R to fresh
gc()
library(ggplot2)
library(scales)
library(sfsmisc)
library(scales)
library(plyr)
library(dplyr)
library(tidyr)
library(pheatmap)
library(lfe)
library(data.table)
library(pryr)
library(stringr)
library(MASS)
#library(ineq)
#==========================================================================
# Andres path
workingfolder <- "~/../Dropbox/Harvard/LittleProjects/StochasticPS/"
#  Declare other paths
folder.data <- paste0(workingfolder,"data/")
folder.datain <- paste0(workingfolder,"inputdata/")
folder.dataout <- paste0(workingfolder,"outputdata/")
folder.figs <- paste0(workingfolder,"figures/")
folder.tables <- paste0(workingfolder,"tables/")
folder.rcodes <- paste0(workingfolder,"programsR/")
setwd(workingfolder)
#source("NHB_9999_functions.R")
#==========================================================================
#==========================================================================
# LOADING DATA
# Back From STATA
filefromstata <- "EComm_0002_2_fromStata2R.csv"
newdf <- as.data.table(rio::import(paste0(folder.dataout, filefromstata)))
ents <- newdf %>%
group_by(year) %>%
summarise(EntropyCommunities_ccp = first(EntropyCommunities_ccp),
EntropyCommunities_cp = first(EntropyCommunities_cp)) %>%
ungroup() %>%
mutate(EntropyCommunities_ccp = EntropyCommunities_ccp/mean(EntropyCommunities_ccp, na.rm=TRUE),
EntropyCommunities_cp = EntropyCommunities_cp/mean(EntropyCommunities_cp, na.rm=TRUE)) %>%
as.data.table()
ents
mult.fig(1)
yrange <- range(c(ents$EntropyCommunities_cp, ents$EntropyCommunities_ccp), na.rm=TRUE)
plot(1, 1,
type = "n",
xlim = range(ents$year),
ylim = yrange,
xlab = "Year",
ylab = "Decoherence")
grid()
abline(lm(ents$EntropyCommunities_ccp ~ ents$year),
col=alpha("darkred", 0.3), lwd=2)
points(ents$year, ents$EntropyCommunities_ccp,
pch=21, bg="darkred", col = "gray", cex=0.5)
abline(lm(ents$EntropyCommunities_cp ~ ents$year),
col=alpha("dodgerblue", 0.5), lwd=4)
points(ents$year, ents$EntropyCommunities_cp,
pch=21, bg="dodgerblue", col = "gray", cex=1.5)
legend("topleft", bg="gray90",
#bty = "n",
inset = c(0.03, 0.03),
legend = c("From Exporter vs. Product", "From Exporter vs. Importer-Product"),
pch = c(21, 21),
pt.bg = c("dodgerblue", "darkred"),
pt.cex = c(1.5, 0.5),
col = c("gray", "gray"))
# =========================================================================
# Growth of distances?
mult.fig(4, mfrow = c(2,2))
plot(leftDistance2Origin_cp ~ year, data=newdf, type="n")
lines(newdf[exporter=="THA"]$year, newdf[exporter=="THA"]$leftDistance2Origin_cp, col = "red")
lines(newdf[exporter=="USA"]$year, newdf[exporter=="USA"]$leftDistance2Origin_cp, col = "green")
lines(newdf[exporter=="CHN"]$year, newdf[exporter=="CHN"]$leftDistance2Origin_cp, col = "blue")
lines(newdf[exporter=="IND"]$year, newdf[exporter=="IND"]$leftDistance2Origin_cp, col = "black")
plot(rightDistance2Origin_cp ~ year, data=newdf, type="n")
lines(newdf[exporter=="THA"]$year, newdf[exporter=="THA"]$rightDistance2Origin_cp, col = "red")
lines(newdf[exporter=="USA"]$year, newdf[exporter=="USA"]$rightDistance2Origin_cp, col = "green")
lines(newdf[exporter=="CHN"]$year, newdf[exporter=="CHN"]$rightDistance2Origin_cp, col = "blue")
lines(newdf[exporter=="IND"]$year, newdf[exporter=="IND"]$rightDistance2Origin_cp, col = "black")
plot(leftSimDirection2MostComplex_cp ~ year, data=newdf, type="n")
lines(newdf[exporter=="THA"]$year, newdf[exporter=="THA"]$leftSimDirection2MostComplex_cp, col = "red")
lines(newdf[exporter=="USA"]$year, newdf[exporter=="USA"]$leftSimDirection2MostComplex_cp, col = "green")
lines(newdf[exporter=="CHN"]$year, newdf[exporter=="CHN"]$leftSimDirection2MostComplex_cp, col = "blue")
lines(newdf[exporter=="IND"]$year, newdf[exporter=="IND"]$leftSimDirection2MostComplex_cp, col = "black")
plot(leftDistance2MostComplex_cp ~ year, data=newdf, type="n")
lines(newdf[exporter=="THA"]$year, newdf[exporter=="THA"]$leftDistance2MostComplex_cp, col = "red")
lines(newdf[exporter=="USA"]$year, newdf[exporter=="USA"]$leftDistance2MostComplex_cp, col = "green")
lines(newdf[exporter=="CHN"]$year, newdf[exporter=="CHN"]$leftDistance2MostComplex_cp, col = "blue")
lines(newdf[exporter=="IND"]$year, newdf[exporter=="IND"]$leftDistance2MostComplex_cp, col = "black")
# =========================================================================
# step AIC on levels
summary(newdf)
colnames(newdf)
fullglm <- glm(loggdppc ~ ., data=subset(newdf, select = -c(exporter, year, population,
#Distance2Origin_cp, SimDirection2MostComplex_ccp,
latitude, longitude, region,
TotalExports, TotalImports, rX10yr, rY10yr,
GDPpcPPPconstant2011intUSD, GDPpcconst2010USD, incomeLevel,
EntropyCommunities_ccp, EntropyCommunities_cp)))
step <- stepAIC(fullglm, trace=TRUE)
step$anova
print(step$formula)
summary(lm(as.formula(step$formula), data=newdf))
# EComm_0004_stability_of_levelregressions.R
# ###########################################################
# Created on 2018-02-07
# Program for eigenspace regressions
# Author: Andres Gomez-Lievano
# ###########################################################
rm(list = ls(all = TRUE))  # resets R to fresh
gc()
library(ggplot2)
library(scales)
library(sfsmisc)
library(scales)
library(plyr)
library(dplyr)
library(tidyr)
library(pheatmap)
library(lfe)
library(data.table)
library(pryr)
library(stringr)
library(MASS)
#library(ineq)
#==========================================================================
# Andres path
workingfolder <- "~/../Dropbox/Harvard/LittleProjects/StochasticPS/"
#  Declare other paths
folder.data <- paste0(workingfolder,"data/")
folder.datain <- paste0(workingfolder,"inputdata/")
folder.dataout <- paste0(workingfolder,"outputdata/")
folder.figs <- paste0(workingfolder,"figures/")
folder.tables <- paste0(workingfolder,"tables/")
folder.rcodes <- paste0(workingfolder,"programsR/")
setwd(workingfolder)
#source("NHB_9999_functions.R")
#==========================================================================
#==========================================================================
# LOADING DATA
# Back From STATA
filefromstata <- "EComm_0002_2_fromStata2R.csv"
newdf <- as.data.table(rio::import(paste0(folder.dataout, filefromstata)))
ents <- newdf %>%
group_by(year) %>%
summarise(EntropyCommunities_ccp = first(EntropyCommunities_ccp),
EntropyCommunities_cp = first(EntropyCommunities_cp)) %>%
ungroup() %>%
mutate(EntropyCommunities_ccp = EntropyCommunities_ccp/mean(EntropyCommunities_ccp, na.rm=TRUE),
EntropyCommunities_cp = EntropyCommunities_cp/mean(EntropyCommunities_cp, na.rm=TRUE)) %>%
as.data.table()
#==========================================================================
# plotting the decline in the number of communities
